<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>TPFinal BCRA</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="TPFinalGPT_files/libs/clipboard/clipboard.min.js"></script>
<script src="TPFinalGPT_files/libs/quarto-html/quarto.js"></script>
<script src="TPFinalGPT_files/libs/quarto-html/popper.min.js"></script>
<script src="TPFinalGPT_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="TPFinalGPT_files/libs/quarto-html/anchor.min.js"></script>
<link href="TPFinalGPT_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="TPFinalGPT_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="TPFinalGPT_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="TPFinalGPT_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="TPFinalGPT_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">TPFinal BCRA</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>CASO Introduccion: ESTUDIO DE LAS DEUDAS REGISTRADAS DEL SISTEMA FINANCIERO ARGENTINO El Banco Central de la República Argentina (BCRA) publica mensualmente un informe consolidado de deudas actuales e históricas (24 meses), denominado ‘Central de Deudores del Sistema Financiero’ elaborado en función de los datos recibidos de distintos tipos de entidades financieras (entidades financieras, empresas no financieras emisoras de tarjetas, fideicomisos financieros, otros proveedores no financieros de crédito, etc.), las cuales deben obligatoriamente remitir mensualmente al BCRA, detallando la totalidad de las financiaciones con la correspondiente situación de cada deudor. Cada deuda informada al BCRA es acompañada de su situación que es una aproximación a la cantidad de días de atraso en el cumplimiento de pago: Situación 1 | Situación normal: atraso en el pago que no supere los 31 días. Situación 2 | Riesgo bajo: atraso en el pago de más de 31 días y hasta 90 días. Situación 3 | Riesgo miedo: atraso en el pago de más de 90 días y hasta 180 días. Situación 4 | Riesgo alto: atraso en el pago de más de 180 días a un año. Situación 5 | Irrecuperable: atraso superior a un año. Situación 6 | Irrecuperable por disposición técnica: deuda con una ex entidad. Se cuenta con una muestra aleatoria de 19.737 cuits de personas físicas que tenían al menos una de deuda en el sistema financiero en Junio de 2019, que se encontraban en situación crediticia 1 o 2 (es decir, que no tuvieran atrasos mayores a 90 días) y cuyo monto total adeudado en ese momento no superaba los 100.000 pesos argentinos. Para los cuits de la muestra aleatoria se registraron y resumieron las deudas en todas las entidades en Junio de 2019 y también 6 meses hacia atrás. También se registraron las deudas de esos cuits entre Julio 2019 y Junio 2020 para poder evaluar su evolución.</p>
<p>Muestra del dataset:</p>
<p>tipo_persona n_deudas_actual proxy_edad_actual deuda_total_actual deuda_con_garantia_actual situacion_mes_actual prop_con_garantia_actual tiene_garantia_actual mora_30_dias_mes_actual n_meses_seg_bcra media_deuda_total media_deuda_situacion_1 media_deuda_situacion_2 media_deuda_con_garantia media_deuda_sin_garantia media_deuda_en_default max_situacion_mes max_sit_mes_con_garantia max_sit_mes_sin_garantia media_prop_situacion_1 media_prop_situacion_2 media_prop_default media_prop_con_garantia prop_tuvo_garantia prop_mora_30_dias_seg prop_default_seg peor_situacion_respuesta default mora_mayor_30_dias 23 1 359 126 126 1 1 1 0 7 156 156 0 153,857142857143 2,14285714285714 0 1 1 1 1 0 0 0,987475247418321 1 0 0 1 0 0 27 1 303 1 0 1 0 0 0 6 2,83333333333333 2,83333333333333 0 0 2,83333333333333 0 1 1 1 0 0 0 0 0 0 1 0 0 27 2 258 14 0 1 0 0 0 7 27,2857142857143 27,2857142857143 0 0 27,2857142857143 0 1 1 1 0 0 0 0 0 0 1 0 0 20 1 274 13 0 2 0 0 1 7 8,85714285714286 7 1,85714285714286 0 8,85714285714286 0 2 2 0,857142857142857 0,142857142857143 0 0 0 0,142857142857143 0 2 0 1 20 2 164 55 0 1 0 0 0 7 67,7142857142857 67,7142857142857 0 0 67,7142857142857 0 1 1 1 0 0 0 0 0 0 1 0 0 27 1 149 24 0 1 0 0 0 7 27,8571428571429 27,8571428571429 0 0 27,8571428571429 0 1 1 1 0 0 0 0 0 0 5 1 1 23 1 174 13 0 1 0 0 0 6 14,8333333333333 14,8333333333333 0 0 14,8333333333333 0 1 1 1 0 0 0 0 0 0 1 0 0 20 2 329 78 0 1 0 0 0 7 54,2857142857143 53,4285714285714 0,857142857142857 0 54,2857142857143 0 2 2 0,976808905380334 0,0231910946196661 0 0 0 0,285714285714286 0 1 0 0 27 3 399 52 0 1 0 0 0 7 42,2857142857143 42,2857142857143 0 0 42,2857142857143 0 1 1 1 0 0 0 0 0 0 1 0 0 20 1 379 8 0 1 0 0 0 7 15,8571428571429 15,8571428571429 0 0 15,8571428571429 0 1 1 1 0 0 0 0 0 0 1 0 0</p>
<p>Descripcion de las variables:</p>
<p>orden, variable, detalle 1, id_individuo, identificación del individuo (anonimizada). 2, tipo_persona, primeros dos dígitos del cuit (20: hombres; 27: mujeres). 3, n_deudas_actual, cantidad de entidades en las que el cuit tenía al menos una deuda en Jun-2019. 4, proxy_edad_actual, tres primeros números del dni. 5, deuda_total_actual, monto total de deuda en Jun-2019 (expresada en miles de pesos). 6, deuda_con_garantia_actual, monto total de deuda garantizada en Jun-2019 (expresada en miles de pesos). 7, situacion_mes_actual, situación crediticia más grave en todas las deudas del cuit en Jun-2019. 8, prop_con_garantia_actual, proporción de la deuda garantizada en Jun-2019 9, tiene_garantia_actual, variable indicadora (0: no, 1: si) de si el cuit tenía al menos una deuda garantizada en Jun-2019. 10, mora_30_dias_mes_actual, variable indicadora (0: no, 1: si) de si el cuit estaba en situación 2 en Jun-2019. 11, n_meses_seg_bcra, cantidad de meses en los que el cuit tenía al menos una deuda informada en el sistema financiero, entre Dic-2018 y Jun-2019. 12, media_deuda_total, promedio de la deuda total entre Dic-2018 y Jun-2019. 13, media_deuda_situacion_1, promedio de la deuda en situación 1 entre Dic-2018 y Jun-2019. 14, media_deuda_situacion_2, promedio de la deuda en situación 2 entre Dic-2018 y Jun-2019. 15, media_deuda_con_garantia, promedio de la deuda garantizada entre Dic-2018 y Jun-2019. 16, media_deuda_sin_garantia, promedio de la deuda no garantizada entre Dic-2018 y Jun-2019. 17, media_deuda_en_default, promedio de la deuda en defaut (situación 3 o peor) entre Dic-2018 y Jun-2019. 18, max_situacion_mes, maxima situación entre Dic-2018 y Jun-2019. 19, max_sit_mes_con_garantia, maxima situación en las deudas garantizadas entre Dic-2018 y Jun-2019. 20, max_sit_mes_sin_garantia, maxima situación en las deudas no garantizadas entre Dic-2018 y Jun-2019. 21, media_prop_situacion_1, promedio de la proporción de deuda en situación 1 entre Dic-2018 y Jun-2019. 22, media_prop_situacion_2, promedio de la proporción de deuda en situación 2 entre Dic-2018 y Jun-2019. 23, media_prop_default, promedio de la proporción de deuda en default entre Dic-2018 y Jun-2019. 24, media_prop_con_garantia, promedio de la proporción de deuda garantizada entre Dic-2018 y Jun-2019. 25, prop_tuvo_garantia, proporción de meses en los cuales el cuit tuvo deuda garantizada, entre Dic-2018 y Jun-2019. 26, prop_mora_30_dias_seg, proporción de meses en los cuales el cuit estuvo en situación 2, entre Dic-2018 y Jun-2019. 27, prop_default_seg, proporción de meses en los cuales el cuit estuvo en default, entre Dic-2018 y Jun-2019. 28, peor_situacion_respuesta, situación crediticia más grave en todas las deudas del cuit entre Jul-2019 y Jun-2020. 29, default, situación crediticia más grave mayor o igual 3 en todas las deudas del cuit entre Jul-2019 y Jun-2020. 30, mora_mayor_30_dias, situación crediticia más grave igual 2 en todas las deudas del cuit entre Jul-2019 y Jun-2020</p>
<p>Consignas a. Describa la distribución univariada de las variables presente en el conjunto de datos. ¿Se evidencian outliers en alguna de ellas? b. Calcule e interprete la matriz de correlaciones de variables disponibles a Jun-2019 (las posibles predictores de default en el período Jul-2019 a Jun-2020). c.&nbsp;Realice un análisis de componentes principales sobre las mismas variables. ¿Qué porcentaje de la variabilidad total logran explicar las dos primeras componentes? ¿Es posible realizar una interpretación sobre los componentes? ¿Cuál? ¿Logran esas componentes diferenciar a los cuits según el tipo de persona? d.&nbsp;¿Existen distintos subgrupos de cuits en los datos? ¿Cuántos logra identificar? ¿Qué características tienen? Explique la metodología utilizada. e. Construya un modelo predictivo para a variable respuesta ‘default’ utilizando sólo las variables disponibles a Jun-2019. ¿Qué capacidad predictiva tiene ese modelo? f.&nbsp;¿Utilizaría el modelo construido para evaluar futuros solicitantes de un crédito? Justifique su respuesta.</p>
<p>Aclaraciones:</p>
<p>Se utilizaran los metodos necesarios: reglas de asociacion, PCA, analisis de clusters, arboles de clasificacion y regresion (cart y/o random forest), siguiendo las pautas de estilo de tidyverse trabajando en R + quarto</p>
<p>Se entiende el problema? Necesitas mas informacion?</p>
<section id="chatgpt-plus" class="level6">
<h6 class="anchored" data-anchor-id="chatgpt-plus">ChatGPT Plus</h6>
<div class="line-block"></div>
<p>Sí, el problema está bien planteado y las consignas son claras. Se realizará un análisis detallado de la distribución de variables, detección de outliers, correlaciones, PCA, clustering y modelado predictivo con CART y/o Random Forest.</p>
<p>Solo unas aclaraciones para confirmar:</p>
<ol type="1">
<li><p>¿Se requiere un preprocesamiento específico, como transformación de variables o imputación de valores faltantes?</p></li>
<li><p>¿Se debe comparar diferentes modelos predictivos o solo uno?</p></li>
<li><p>¿Se usará una métrica específica para evaluar el modelo (AUC, precisión, F1-score, etc.)?</p></li>
<li><p>¿El objetivo final es solo evaluar la capacidad predictiva o también proporcionar recomendaciones sobre la concesión de créditos?</p></li>
</ol>
<p>Si hay algún otro detalle relevante, avísame antes de comenzar.</p>
</section>
<section id="tú-dijiste" class="level5">
<h5 class="anchored" data-anchor-id="tú-dijiste">Tú dijiste:</h5>
<p>1. si. a la columna max_sit_mes_con_garantia, asignarle 0 si la deuda con garantia actual es 0 y tiene NA 2. si 3. usar al menos 5 metricas para compararlos 4. ambas: evaluar la capacidad predictiva y proporcionar las recomendaciones</p>
<section id="chatgpt-plus-1" class="level6">
<h6 class="anchored" data-anchor-id="chatgpt-plus-1">ChatGPT Plus</h6>
<div class="line-block"></div>
<p>Perfecto, con esos puntos en claro, podemos avanzar.</p>
<p>Voy a estructurar el análisis en los siguientes pasos:</p>
<ol type="1">
<li><p><strong>Limpieza y preprocesamiento de datos</strong></p>
<ul>
<li><p>Imputación de <code>max_sit_mes_con_garantia</code>.</p></li>
<li><p>Detección y tratamiento de outliers si es necesario.</p></li>
<li><p>Transformaciones o normalizaciones necesarias.</p></li>
</ul></li>
<li><p><strong>Análisis exploratorio de datos (EDA)</strong></p>
<ul>
<li><p>Distribuciones univariadas de las variables.</p></li>
<li><p>Detección visual y estadística de outliers.</p></li>
<li><p>Correlaciones entre las variables predictoras.</p></li>
</ul></li>
<li><p><strong>Reducción de dimensionalidad (PCA)</strong></p>
<ul>
<li><p>Análisis de componentes principales.</p></li>
<li><p>Interpretación de las principales componentes.</p></li>
<li><p>Evaluación de si diferencian los tipos de personas.</p></li>
</ul></li>
<li><p><strong>Segmentación de clientes (Clustering)</strong></p>
<ul>
<li><p>Identificación de grupos dentro de los deudores.</p></li>
<li><p>Caracterización de los segmentos encontrados.</p></li>
</ul></li>
<li><p><strong>Modelado predictivo del default</strong></p>
<ul>
<li><p>Construcción de al menos dos modelos (CART, Random Forest, otros).</p></li>
<li><p>Comparación con al menos cinco métricas de desempeño.</p></li>
<li><p>Evaluación de importancia de variables.</p></li>
</ul></li>
<li><p><strong>Recomendaciones y conclusiones</strong></p>
<ul>
<li><p>Evaluación del uso del modelo para futuros créditos.</p></li>
<li><p>Limitaciones del análisis y posibles mejoras.</p></li>
</ul></li>
</ol>
<p>Voy a comenzar con la limpieza e imputación de datos en R. ¿Querés que incluya código y explicaciones en cada paso o solo el código con comentarios?</p>
</section>
</section>
<section id="tú-dijiste-1" class="level5">
<h5 class="anchored" data-anchor-id="tú-dijiste-1">Tú dijiste:</h5>
<p>si, por favor</p>
<section id="chatgpt-plus-2" class="level6">
<h6 class="anchored" data-anchor-id="chatgpt-plus-2">ChatGPT Plus</h6>
<p>Voy a comenzar con el <strong>preprocesamiento de datos</strong>, centrándome en la imputación de <code>max_sit_mes_con_garantia</code>.</p>
</section>
</section>
<section id="paso-1-limpieza-e-imputación-de-datos" class="level3">
<h3 class="anchored" data-anchor-id="paso-1-limpieza-e-imputación-de-datos">📌 <strong>Paso 1: Limpieza e imputación de datos</strong></h3>
<p>La columna <code>max_sit_mes_con_garantia</code> debe tomar el valor <strong>0 si <code>deuda_con_garantia_actual</code> es 0 y tiene NA</strong>.</p>
<p>Aquí está el código en R con <code>tidyverse</code>:</p>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code># Cargar paquetes necesarios
library(tidyverse)

# Simulación de datos de ejemplo
set.seed(123)
datos &lt;- tibble(
  deuda_con_garantia_actual = c(0, 1, 0, 1, 0, 0, 1, NA, 0, 1),
  max_sit_mes_con_garantia = c(NA, 3, NA, 2, NA, 4, 1, 5, NA, NA)
)

# Aplicar la imputación: si deuda_con_garantia_actual es 0 y max_sit_mes_con_garantia es NA, se asigna 0
datos &lt;- datos %&gt;%
  mutate(max_sit_mes_con_garantia = if_else(
    is.na(max_sit_mes_con_garantia) &amp; deuda_con_garantia_actual == 0, 
    0, 
    max_sit_mes_con_garantia
  ))

# Ver resultado
print(datos)</code></pre>
<p>🔹 <strong>Explicación del código:</strong></p>
<ul>
<li><p>Se usa <code>mutate()</code> para modificar <code>max_sit_mes_con_garantia</code>.</p></li>
<li><p><code>if_else()</code> verifica si el valor es NA y si <code>deuda_con_garantia_actual</code> es 0.</p></li>
<li><p>En esos casos, se reemplaza con <strong>0</strong>, en los demás se mantiene el valor original.</p></li>
</ul>
<hr>
</section>
<section id="siguientes-pasos" class="level3">
<h3 class="anchored" data-anchor-id="siguientes-pasos">📊 <strong>Siguientes pasos</strong></h3>
<p>Si esta imputación está bien, avanzamos con:</p>
<ol type="1">
<li><p><strong>Detección y tratamiento de outliers</strong></p></li>
<li><p><strong>EDA (Análisis Exploratorio de Datos)</strong></p></li>
</ol>
<p>¿Querés que analicemos outliers en alguna variable en particular?</p>
<section id="tú-dijiste-2" class="level5">
<h5 class="anchored" data-anchor-id="tú-dijiste-2">Tú dijiste:</h5>
<p>analiza outliers en todas las variables que sea necesario y factible hacerlo</p>
<section id="chatgpt-plus-3" class="level6">
<h6 class="anchored" data-anchor-id="chatgpt-plus-3">ChatGPT Plus</h6>
<p>Voy a analizar los <strong>outliers</strong> en todas las variables numéricas del dataset. Utilizaré el método de <strong>caja y bigotes (IQR)</strong> para identificar valores atípicos.</p>
<hr>
</section>
</section>
</section>
<section id="paso-1-identificar-variables-numéricas" class="level3">
<h3 class="anchored" data-anchor-id="paso-1-identificar-variables-numéricas">📌 <strong>Paso 1: Identificar variables numéricas</strong></h3>
<p>Usaremos <code>select(where(is.numeric))</code> para trabajar solo con las variables numéricas.</p>
</section>
<section id="paso-2-detección-de-outliers-con-iqr" class="level3">
<h3 class="anchored" data-anchor-id="paso-2-detección-de-outliers-con-iqr">📌 <strong>Paso 2: Detección de outliers con IQR</strong></h3>
<p>Un valor es considerado <strong>outlier</strong> si está fuera del rango:</p>
<p>[Q1−1.5×IQR,Q3+1.5×IQR][Q1−1.5×IQR,Q3+1.5×IQR]</p>
<p>donde:</p>
<ul>
<li><p><strong>Q1</strong> es el <strong>percentil 25</strong></p></li>
<li><p><strong>Q3</strong> es el <strong>percentil 75</strong></p></li>
<li><p><strong>IQR</strong> es la <strong>diferencia entre Q3 y Q1</strong></p></li>
</ul>
<p>Aquí está el código en R:</p>
<hr>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code># Cargar paquetes
library(tidyverse)

# Función para detectar outliers con IQR
detectar_outliers &lt;- function(df) {
  df %&gt;%
    select(where(is.numeric)) %&gt;%  # Filtrar solo columnas numéricas
    pivot_longer(everything(), names_to = "variable", values_to = "valor") %&gt;%
    group_by(variable) %&gt;%
    summarise(
      Q1 = quantile(valor, 0.25, na.rm = TRUE),
      Q3 = quantile(valor, 0.75, na.rm = TRUE),
      IQR = Q3 - Q1,
      Limite_Inferior = Q1 - 1.5 * IQR,
      Limite_Superior = Q3 + 1.5 * IQR,
      Outliers = sum(valor &lt; Limite_Inferior | valor &gt; Limite_Superior, na.rm = TRUE),
      Total_Datos = sum(!is.na(valor)),
      Porcentaje_Outliers = round((Outliers / Total_Datos) * 100, 2)
    ) %&gt;%
    arrange(desc(Porcentaje_Outliers))
}

# Aplicar función al dataset
resumen_outliers &lt;- detectar_outliers(datos)

# Mostrar resultado
print(resumen_outliers)</code></pre>
<hr>
</section>
<section id="interpretación-del-resultado" class="level3">
<h3 class="anchored" data-anchor-id="interpretación-del-resultado">📊 <strong>Interpretación del resultado</strong></h3>
<ol type="1">
<li><p><strong>La tabla muestra</strong>:</p>
<ul>
<li><p>La cantidad de outliers por variable</p></li>
<li><p>El porcentaje de datos atípicos</p></li>
<li><p>Los límites superior e inferior</p></li>
</ul></li>
<li><p><strong>Si una variable tiene muchos outliers</strong>, podemos:</p>
<ul>
<li><p><strong>Mantenerlos</strong>, si tienen significado dentro del contexto</p></li>
<li><p><strong>Caparlos (Winsorizing)</strong> si son extremos pero reales</p></li>
<li><p><strong>Eliminar valores erróneos</strong>, si se deben a errores de carga</p></li>
</ul></li>
</ol>
<hr>
</section>
<section id="siguientes-pasos-1" class="level3">
<h3 class="anchored" data-anchor-id="siguientes-pasos-1">📌 <strong>Siguientes pasos</strong></h3>
<p>🔹 <strong>¿Te gustaría visualizar los outliers con boxplots antes de decidir cómo tratarlos?</strong></p>
<section id="tú-dijiste-3" class="level5">
<h5 class="anchored" data-anchor-id="tú-dijiste-3">Tú dijiste:</h5>
<p>si, por favor, y agregar el codigo para visualizacion en una matriz de 6 columnas</p>
<section id="chatgpt-plus-4" class="level6">
<h6 class="anchored" data-anchor-id="chatgpt-plus-4">ChatGPT Plus</h6>
<p>Voy a generar una <strong>matriz de boxplots</strong> con 6 columnas para visualizar los outliers de las variables numéricas.</p>
<hr>
</section>
</section>
</section>
<section id="código-r-para-visualización" class="level3">
<h3 class="anchored" data-anchor-id="código-r-para-visualización">📌 <strong>Código R para visualización</strong></h3>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code># Cargar paquetes
library(tidyverse)
library(ggplot2)

# Función para graficar boxplots en una matriz de 6 columnas
graficar_boxplots &lt;- function(df) {
  df %&gt;%
    select(where(is.numeric)) %&gt;%
    pivot_longer(everything(), names_to = "variable", values_to = "valor") %&gt;%
    ggplot(aes(x = variable, y = valor)) +
    geom_boxplot(outlier.color = "red", outlier.shape = 16, outlier.size = 2) +
    facet_wrap(~variable, scales = "free", ncol = 6) +  # Matriz de 6 columnas
    theme_minimal() +
    theme(axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          strip.text = element_text(size = 10, face = "bold")) +
    labs(title = "Distribución de Outliers por Variable",
         y = "Valor", x = "")
}

# Aplicar la función al dataset
graficar_boxplots(datos)</code></pre>
<hr>
</section>
<section id="explicación-del-código" class="level3">
<h3 class="anchored" data-anchor-id="explicación-del-código">📊 <strong>Explicación del código</strong></h3>
<ol type="1">
<li><p><strong>Se seleccionan las variables numéricas</strong> con <code>select(where(is.numeric))</code>.</p></li>
<li><p><strong>Se reorganizan en formato largo</strong> (<code>pivot_longer</code>) para facilitar la visualización.</p></li>
<li><p><strong>Se genera un boxplot por variable</strong> con <code>geom_boxplot()</code>, resaltando outliers en rojo.</p></li>
<li><p><strong>Los gráficos se organizan en una matriz de 6 columnas</strong> (<code>facet_wrap(~variable, ncol = 6)</code>).</p></li>
<li><p><strong>Se mejora el diseño con <code>theme_minimal()</code></strong> y se eliminan etiquetas innecesarias.</p></li>
</ol>
<hr>
</section>
<section id="cómo-interpretar-los-gráficos" class="level3">
<h3 class="anchored" data-anchor-id="cómo-interpretar-los-gráficos">📌 <strong>¿Cómo interpretar los gráficos?</strong></h3>
<ul>
<li><p><strong>Puntos rojos</strong> → outliers detectados.</p></li>
<li><p><strong>Si hay valores extremadamente alejados</strong>, analizar si deben <strong>tratarse o mantenerse</strong>.</p></li>
</ul>
<p>🔹 <strong>¿Quieres que implemente una estrategia automática para tratarlos?</strong> (Ejemplo: Winsorizing, eliminación, etc.)</p>
<section id="tú-dijiste-4" class="level5">
<h5 class="anchored" data-anchor-id="tú-dijiste-4">Tú dijiste:</h5>
<p>como podriamos manejar los outliers usando clustering?</p>
<section id="chatgpt-plus-5" class="level6">
<h6 class="anchored" data-anchor-id="chatgpt-plus-5">ChatGPT Plus</h6>
<p>Podemos manejar los <strong>outliers</strong> usando <strong>clustering</strong> de varias maneras. Un enfoque común es usar un <strong>modelo de clustering</strong> para detectar observaciones que están <strong>aisladas</strong> o <strong>pertenecen a un pequeño grupo separado</strong>. Algunas opciones son:</p>
<hr>
</section>
</section>
</section>
<section id="métodos-de-clustering-para-detectar-outliers" class="level3">
<h3 class="anchored" data-anchor-id="métodos-de-clustering-para-detectar-outliers">📌 <strong>Métodos de Clustering para Detectar Outliers</strong></h3>
<section id="dbscan-density-based-spatial-clustering-of-applications-with-noise" class="level4">
<h4 class="anchored" data-anchor-id="dbscan-density-based-spatial-clustering-of-applications-with-noise"><strong>1️⃣ DBSCAN (Density-Based Spatial Clustering of Applications with Noise)</strong></h4>
<ul>
<li><p>Detecta outliers como <strong>ruido</strong> (puntos que no pertenecen a ningún clúster denso).</p></li>
<li><p>Ideal para conjuntos de datos con <strong>formas irregulares</strong>.</p></li>
<li><p>No requiere especificar el número de clústeres.</p></li>
<li><p>Identifica los puntos alejados del resto como <strong>outliers</strong>.</p></li>
</ul>
</section>
<section id="k-means-distancia-al-centroide" class="level4">
<h4 class="anchored" data-anchor-id="k-means-distancia-al-centroide"><strong>2️⃣ K-Means + Distancia al Centroide</strong></h4>
<ul>
<li><p>Se asigna cada observación a un <strong>clúster</strong>.</p></li>
<li><p>Los puntos con mayor <strong>distancia al centroide</strong> pueden considerarse <strong>outliers</strong>.</p></li>
<li><p>Se pueden definir <strong>umbrales</strong> para marcar valores anómalos.</p></li>
</ul>
</section>
<section id="isolation-forest-o-lof-local-outlier-factor" class="level4">
<h4 class="anchored" data-anchor-id="isolation-forest-o-lof-local-outlier-factor"><strong>3️⃣ Isolation Forest o LOF (Local Outlier Factor)</strong></h4>
<ul>
<li><p>Técnicas especializadas en detección de anomalías que pueden combinarse con clustering.</p></li>
<li><p>Isolation Forest aísla anomalías en pocas iteraciones.</p></li>
<li><p>LOF evalúa la densidad local y detecta puntos con densidad baja.</p></li>
</ul>
<hr>
</section>
</section>
<section id="implementación-en-r-con-dbscan" class="level3">
<h3 class="anchored" data-anchor-id="implementación-en-r-con-dbscan">📌 <strong>Implementación en R con DBSCAN</strong></h3>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code># Cargar paquetes
library(dbscan)
library(ggplot2)
library(tidyverse)

# Normalizar las variables numéricas
datos_norm &lt;- datos %&gt;%
  select(where(is.numeric)) %&gt;%
  scale()

# Aplicar DBSCAN (parámetros óptimos deben ajustarse según el dataset)
modelo_dbscan &lt;- dbscan(datos_norm, eps = 0.5, minPts = 5)

# Agregar etiquetas de cluster y detectar outliers (-1 en DBSCAN)
datos &lt;- datos %&gt;%
  mutate(cluster = as.factor(modelo_dbscan$cluster),
         outlier = ifelse(cluster == "-1", "Sí", "No"))

# Visualización: PCA para reducir dimensiones
pca &lt;- prcomp(datos_norm, center = TRUE, scale. = TRUE)
df_pca &lt;- as.data.frame(pca$x[, 1:2]) %&gt;%
  mutate(cluster = datos$cluster, outlier = datos$outlier)

ggplot(df_pca, aes(x = PC1, y = PC2, color = outlier)) +
  geom_point(alpha = 0.7, size = 3) +
  labs(title = "Detección de Outliers con DBSCAN",
       x = "Componente Principal 1", y = "Componente Principal 2") +
  scale_color_manual(values = c("No" = "blue", "Sí" = "red")) +
  theme_minimal()</code></pre>
<hr>
</section>
<section id="explicación" class="level3">
<h3 class="anchored" data-anchor-id="explicación">📌 <strong>Explicación</strong></h3>
<ol type="1">
<li><p><strong>Se normalizan las variables numéricas</strong> para evitar sesgos por escalas diferentes.</p></li>
<li><p><strong>Se aplica DBSCAN</strong> para identificar outliers (los que no pertenecen a ningún grupo).</p></li>
<li><p><strong>Se usa PCA</strong> para reducir la dimensionalidad y visualizar los resultados.</p></li>
<li><p><strong>Los puntos rojos en el gráfico</strong> representan los <strong>outliers detectados</strong>.</p></li>
</ol>
<hr>
<p>🔹 <strong>¿Quieres que probemos otro método como K-Means o Isolation Forest?</strong></p>
<section id="tú-dijiste-5" class="level5">
<h5 class="anchored" data-anchor-id="tú-dijiste-5">Tú dijiste:</h5>
<p>si, por favor, con ambos</p>
<section id="chatgpt-plus-6" class="level6">
<h6 class="anchored" data-anchor-id="chatgpt-plus-6">ChatGPT Plus</h6>
<p>Aquí tienes la implementación de <strong>K-Means con distancia al centroide</strong> e <strong>Isolation Forest</strong> para detectar outliers en tu dataset.</p>
<hr>
</section>
</section>
</section>
<section id="k-means-distancia-al-centroide-1" class="level2">
<h2 class="anchored" data-anchor-id="k-means-distancia-al-centroide-1">📌 <strong>1️⃣ K-Means + Distancia al Centroide</strong></h2>
<p><strong>Idea:</strong> Los outliers son los puntos más alejados del centroide de su clúster.</p>
<section id="código-en-r" class="level3">
<h3 class="anchored" data-anchor-id="código-en-r"><strong>Código en R</strong></h3>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code># Cargar paquetes
library(tidyverse)
library(cluster)
library(ggplot2)

# Normalizar las variables numéricas
datos_norm &lt;- datos %&gt;%
  select(where(is.numeric)) %&gt;%
  scale()

# Determinar el número óptimo de clústeres con el método del codo
set.seed(123)
wss &lt;- map_dbl(1:10, ~kmeans(datos_norm, centers = .x, nstart = 25)$tot.withinss)

ggplot(data.frame(Clusters = 1:10, WSS = wss), aes(x = Clusters, y = WSS)) +
  geom_line() +
  geom_point() +
  labs(title = "Método del Codo para K-Means", x = "Número de Clústeres", y = "Suma de Cuadrados")

# Aplicar K-Means con el número óptimo de clusters (ajustar según gráfico)
k &lt;- 4  # Ajustar según el codo
modelo_kmeans &lt;- kmeans(datos_norm, centers = k, nstart = 25)

# Calcular distancia al centroide más cercano
distancias &lt;- apply(modelo_kmeans$centers[modelo_kmeans$cluster, ], 1, function(centroide) {
  sqrt(rowSums((datos_norm - centroide)^2))
})

# Identificar outliers como los puntos con distancia más alta (percentil 95)
umbral &lt;- quantile(distancias, 0.95)
datos &lt;- datos %&gt;%
  mutate(cluster_kmeans = as.factor(modelo_kmeans$cluster),
         outlier_kmeans = ifelse(distancias &gt; umbral, "Sí", "No"))

# Visualización con PCA
pca &lt;- prcomp(datos_norm, center = TRUE, scale. = TRUE)
df_pca &lt;- as.data.frame(pca$x[, 1:2]) %&gt;%
  mutate(cluster = datos$cluster_kmeans, outlier = datos$outlier_kmeans)

ggplot(df_pca, aes(x = PC1, y = PC2, color = outlier)) +
  geom_point(alpha = 0.7, size = 3) +
  labs(title = "Detección de Outliers con K-Means",
       x = "Componente Principal 1", y = "Componente Principal 2") +
  scale_color_manual(values = c("No" = "blue", "Sí" = "red")) +
  theme_minimal()</code></pre>
<hr>
</section>
</section>
<section id="isolation-forest" class="level2">
<h2 class="anchored" data-anchor-id="isolation-forest">📌 <strong>2️⃣ Isolation Forest</strong></h2>
<p><strong>Idea:</strong> Un algoritmo de bosque aleatorio que aísla outliers en menos iteraciones.</p>
<section id="código-en-r-1" class="level3">
<h3 class="anchored" data-anchor-id="código-en-r-1"><strong>Código en R</strong></h3>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code># Cargar paquete
library(isotree)

# Entrenar modelo de Isolation Forest
modelo_iforest &lt;- isolation.forest(datos_norm, ntrees = 100)

# Obtener puntajes de anomalía (cuanto mayor, más probable que sea outlier)
scores &lt;- predict(modelo_iforest, datos_norm, type = "score")

# Definir umbral de outlier (percentil 95)
umbral_iforest &lt;- quantile(scores, 0.95)
datos &lt;- datos %&gt;%
  mutate(outlier_iforest = ifelse(scores &gt; umbral_iforest, "Sí", "No"))

# Visualización con PCA
df_pca &lt;- df_pca %&gt;%
  mutate(outlier_iforest = datos$outlier_iforest)

ggplot(df_pca, aes(x = PC1, y = PC2, color = outlier_iforest)) +
  geom_point(alpha = 0.7, size = 3) +
  labs(title = "Detección de Outliers con Isolation Forest",
       x = "Componente Principal 1", y = "Componente Principal 2") +
  scale_color_manual(values = c("No" = "blue", "Sí" = "red")) +
  theme_minimal()</code></pre>
<hr>
</section>
</section>
<section id="resumen" class="level2">
<h2 class="anchored" data-anchor-id="resumen">📌 <strong>Resumen</strong></h2>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Método</th>
<th>Ventajas</th>
<th>Desventajas</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>DBSCAN</strong></td>
<td>Detecta outliers sin necesidad de predefinir <code>k</code>. Ideal para datos con formas irregulares.</td>
<td>Sensible a <code>eps</code> y <code>minPts</code>, puede fallar en datos de alta dimensión.</td>
</tr>
<tr class="even">
<td><strong>K-Means + Distancia</strong></td>
<td>Fácil de interpretar y visualizar. Funciona bien en datos estructurados.</td>
<td>Necesita definir <code>k</code>, no detecta bien outliers en datos no esféricos.</td>
</tr>
<tr class="odd">
<td><strong>Isolation Forest</strong></td>
<td>Eficiente en grandes volúmenes de datos, no necesita definir <code>k</code>.</td>
<td>Puede ser menos interpretable que K-Means.</td>
</tr>
</tbody>
</table>
<p>🔹 <strong>¿Cuál de los métodos te resulta más útil para tu análisis?</strong> 🚀</p>
<section id="tú-dijiste-6" class="level5">
<h5 class="anchored" data-anchor-id="tú-dijiste-6">Tú dijiste:</h5>
<p>usar un metodo de aglomeracion jerarquico usando dendogramas e identificar los clusters usando el indice silhouette</p>
<section id="chatgpt-plus-7" class="level6">
<h6 class="anchored" data-anchor-id="chatgpt-plus-7">ChatGPT Plus</h6>
<p>Aquí tienes el análisis de clustering jerárquico con dendrogramas e identificación de clusters mediante el <strong>índice de Silhouette</strong> en R.</p>
<hr>
</section>
</section>
</section>
<section id="clustering-jerárquico-dendrograma" class="level2">
<h2 class="anchored" data-anchor-id="clustering-jerárquico-dendrograma">📌 <strong>1️⃣ Clustering Jerárquico + Dendrograma</strong></h2>
<p><strong>Idea:</strong> Agrupamos las observaciones basándonos en similitud y visualizamos la estructura en un dendrograma.</p>
<section id="código-en-r-2" class="level3">
<h3 class="anchored" data-anchor-id="código-en-r-2"><strong>Código en R</strong></h3>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code># Cargar paquetes
library(tidyverse)
library(cluster)
library(factoextra)

# Normalizar los datos numéricos
datos_norm &lt;- datos %&gt;%
  select(where(is.numeric)) %&gt;%
  scale()

# Crear una matriz de distancias (método Euclidiano)
dist_matrix &lt;- dist(datos_norm, method = "euclidean")

# Aplicar clustering jerárquico usando el método de Ward
hclust_model &lt;- hclust(dist_matrix, method = "ward.D2")

# Visualizar el dendrograma
fviz_dend(hclust_model, k = 4, 
          cex = 0.7, 
          rect = TRUE, 
          rect_fill = TRUE, 
          rect_border = "blue", 
          main = "Dendrograma - Clustering Jerárquico")</code></pre>
<hr>
</section>
</section>
<section id="determinación-del-número-óptimo-de-clusters-con-el-índice-de-silhouette" class="level2">
<h2 class="anchored" data-anchor-id="determinación-del-número-óptimo-de-clusters-con-el-índice-de-silhouette">📌 <strong>2️⃣ Determinación del Número Óptimo de Clusters con el Índice de Silhouette</strong></h2>
<p><strong>Idea:</strong> Se evalúa qué cantidad de clusters es óptima en base a la separación y cohesión de los grupos.</p>
<section id="código-en-r-3" class="level3">
<h3 class="anchored" data-anchor-id="código-en-r-3"><strong>Código en R</strong></h3>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code># Evaluar el índice de Silhouette para distintos valores de k
silhouette_scores &lt;- map_dbl(2:10, function(k) {
  cluster_assignments &lt;- cutree(hclust_model, k = k)
  mean(silhouette(cluster_assignments, dist_matrix)[, 3])
})

# Visualizar el índice de Silhouette
sil_df &lt;- tibble(k = 2:10, Silhouette = silhouette_scores)
ggplot(sil_df, aes(x = k, y = Silhouette)) +
  geom_line() +
  geom_point(size = 3, color = "red") +
  labs(title = "Índice de Silhouette para Diferentes Clusters",
       x = "Número de Clusters", y = "Índice de Silhouette") +
  theme_minimal()

# Seleccionar el número óptimo de clusters (máximo índice de Silhouette)
optimo_k &lt;- sil_df$k[which.max(sil_df$Silhouette)]
cat("Número óptimo de clusters según Silhouette:", optimo_k, "\n")

# Asignar clusters a cada observación usando el número óptimo
datos &lt;- datos %&gt;%
  mutate(cluster_hclust = cutree(hclust_model, k = optimo_k))</code></pre>
<hr>
</section>
</section>
<section id="visualización-de-los-clusters-con-pca" class="level2">
<h2 class="anchored" data-anchor-id="visualización-de-los-clusters-con-pca">📌 <strong>3️⃣ Visualización de los Clusters con PCA</strong></h2>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code># Aplicar PCA para visualización
pca &lt;- prcomp(datos_norm, center = TRUE, scale. = TRUE)
df_pca &lt;- as.data.frame(pca$x[, 1:2]) %&gt;%
  mutate(cluster = as.factor(datos$cluster_hclust))

# Graficar los clusters en el espacio PCA
ggplot(df_pca, aes(x = PC1, y = PC2, color = cluster)) +
  geom_point(alpha = 0.7, size = 3) +
  labs(title = "Clusters Identificados con Clustering Jerárquico",
       x = "Componente Principal 1", y = "Componente Principal 2") +
  theme_minimal()</code></pre>
<hr>
</section>
<section id="resumen-de-resultados" class="level2">
<h2 class="anchored" data-anchor-id="resumen-de-resultados">📌 <strong>Resumen de Resultados</strong></h2>
<p>1️⃣ Se generó un dendrograma para visualizar la estructura de los datos.<br>
2️⃣ Se usó el <strong>índice de Silhouette</strong> para determinar el número óptimo de clusters.<br>
3️⃣ Se asignaron clusters y se visualizó la distribución en un <strong>gráfico PCA</strong>.</p>
<p>🔹 <strong>¿Te gustaría que analicemos más características de los clusters formados?</strong> 🚀</p>
<p>ChatGPT puede cometer errores. Considera verificar la información importante.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>